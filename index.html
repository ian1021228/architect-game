<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¯æ„›é¢¨2Då‰µä¸–ç¥</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #e0f7fa;
            font-family: 'Nunito', sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 20px;
            display: flex;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            pointer-events: auto;
            overflow-x: auto;
            max-width: 90%;
            transition: bottom 0.3s ease-in-out;
            align-items: center;
        }

        #toolbar.hidden {
            display: none;
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            border: 3px solid #ddd;
            border-radius: 12px;
            background: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: transform 0.1s, border-color 0.2s;
            flex-shrink: 0;
        }

        .tool-btn.active {
            border-color: #ff9800;
            transform: scale(1.1);
            background: #fff3e0;
        }

        .tool-btn:active {
            transform: scale(0.95);
        }

        /* æ—‹è½‰æŒ‰éˆ• */
        #rotate-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #2196f3;
            border-radius: 50%;
            background: #e3f2fd;
            color: #2196f3;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin-left: 10px;
            flex-shrink: 0;
            transition: transform 0.2s;
        }
        
        #rotate-btn:active {
            transform: rotate(90deg);
        }

        #mode-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: #4caf50;
            border-radius: 50%;
            border: 4px solid white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: white;
            z-index: 100;
        }

        #mode-switch.playing {
            background: #f44336;
        }

        #message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #mobile-controls {
            display: none; 
            pointer-events: auto;
        }

        .control-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            user-select: none;
            border: 2px solid rgba(0,0,0,0.1);
        }

        #btn-left { bottom: 30px; left: 20px; }
        #btn-right { bottom: 30px; left: 100px; }
        #btn-jump { bottom: 30px; right: 30px; background: rgba(255, 200, 200, 0.6); }

        @media (max-width: 768px) {
            #mobile-controls.active {
                display: block;
            }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="message">æç¤ºè¨Šæ¯</div>

        <div id="mode-switch" onclick="toggleMode()">â–¶ï¸</div>

        <div id="toolbar">
            <div class="tool-btn active" onclick="selectTool('ground')" title="æ–¹å¡Š">ğŸŸ«</div>
            <div class="tool-btn" onclick="selectTool('player')" title="ä¸»è§’">ğŸŸ¡</div>
            <div class="tool-btn" onclick="selectTool('spike')" title="å°–åˆº">ğŸ”º</div>
            <div class="tool-btn" onclick="selectTool('conveyor')" title="è¼¸é€å¸¶">â©</div>
            <div class="tool-btn" onclick="selectTool('spring')" title="è·³æ¿">â«</div>
            <div class="tool-btn" onclick="selectTool('pushbox')" title="å¯æ¨å‹•æ–¹å¡Š">ğŸ“¦</div>
            <div class="tool-btn" onclick="selectTool('monster')" title="æ€ªç‰©">ğŸ‘¾</div>
            <div class="tool-btn" onclick="selectTool('eraser')" title="æ©¡çš®æ“¦">âŒ</div>
            
            <div id="rotate-btn" onclick="toggleBuildDir()" title="æ—‹è½‰æ–¹å‘ (R)">â¡ï¸</div>
        </div>

        <div id="mobile-controls">
            <div id="btn-left" class="control-btn">â¬…ï¸</div>
            <div id="btn-right" class="control-btn">â¡ï¸</div>
            <div id="btn-jump" class="control-btn">â¬†ï¸</div>
        </div>
    </div>

<script>
/**
 * éŠæˆ²æ ¸å¿ƒé‚è¼¯
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// å…¨å±€è¨­å®š
const TILE_SIZE = 60;
const GRAVITY = 0.6;
const TERMINAL_VELOCITY = 15;

// éŠæˆ²ç‹€æ…‹
let mode = 'build';
let tiles = {}; 
let dynamicObjects = []; 
let particles = []; 

let camera = { x: 0, y: 0 };
let currentTool = 'ground';
// æ–¹å‘ç³»çµ±: 0:å³, 1:ä¸‹, 2:å·¦, 3:ä¸Š
let buildDir = 0; 
const DIR_NAMES = ['right', 'down', 'left', 'up'];

let isDraggingCamera = false;
let lastMousePos = { x: 0, y: 0 };

let keys = { ArrowUp: false, ArrowLeft: false, ArrowRight: false, ArrowDown: false, KeyW: false, KeyA: false, KeyD: false, KeyS: false };
let touchInputs = { left: false, right: false, jump: false };

let savedMapData = null;

// è³‡æºé¡è‰²
const COLORS = {
    sky: '#e0f7fa',
    ground: '#8d6e63',
    grass: '#81c784',
    spike: '#bdbdbd',
    conveyor: '#424242',
    spring: '#66bb6a', // ç¶ è‰²è·³æ¿
    pushbox: '#ffcc80',
    monster: '#b39ddb',
    monsterEyes: '#d50000',
    playerMain: '#fdd835',
    playerStroke: '#fbc02d'
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// =========================================
// ç¹ªåœ–å·¥å…·å‡½æ•¸
// =========================================

function drawRoundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

function drawTileGraphic(ctx, fullType, x, y, w, h, isGrassBlocked = false) {
    let type = fullType;
    let rotation = 0; // Radians

    // è§£ææ–¹å‘
    if (fullType.includes('_')) {
        let parts = fullType.split('_');
        type = parts[0];
        let dirStr = parts[1];
        let dirIndex = DIR_NAMES.indexOf(dirStr);
        if (dirIndex !== -1) {
            rotation = dirIndex * (Math.PI / 2);
        }
    }

    if (type === 'ground') {
        ctx.fillStyle = COLORS.ground;
        drawRoundedRect(ctx, x, y, w, h, 4);
        ctx.fill();
        // åªæœ‰ç•¶ä¸Šæ–¹æ²’æœ‰æ–¹å¡Šæ™‚æ‰ç•«è‰
        if (!isGrassBlocked) {
            ctx.fillStyle = COLORS.grass;
            ctx.fillRect(x, y, w, 10);
        }
    } else if (type === 'spike') {
        ctx.fillStyle = COLORS.spike;
        ctx.beginPath();
        ctx.moveTo(x, y + h);
        ctx.lineTo(x + w/2, y);
        ctx.lineTo(x + w, y + h);
        ctx.fill();
    } else if (type === 'conveyor') {
        ctx.save();
        ctx.translate(x + w/2, y + h/2);
        ctx.rotate(rotation);
        ctx.translate(-w/2, -h/2);

        ctx.beginPath();
        drawRoundedRect(ctx, 0, 0, w, h, 0);
        ctx.clip();

        ctx.fillStyle = COLORS.conveyor;
        ctx.fillRect(0, 0, w, h);
        
        ctx.fillStyle = '#9e9e9e';
        let speed = 2;
        let offset = (Date.now() * 0.1 * speed) % w;
        if (offset < 0) offset += w;

        for(let i=-1; i<2; i++) {
             let lineX = offset + (i * w);
             ctx.save();
             ctx.translate(lineX, h/2);
             ctx.fillStyle = '#ffffff';
             ctx.beginPath();
             ctx.moveTo(-5, -10);
             ctx.lineTo(5, 0);
             ctx.lineTo(-5, 10);
             ctx.lineTo(-5, 5);
             ctx.lineTo(-15, 5);
             ctx.lineTo(-15, -5);
             ctx.lineTo(-5, -5);
             ctx.fill();
             ctx.restore();
        }
        ctx.strokeStyle = '#616161';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, w, h);
        ctx.restore();

    } else if (type === 'spring') {
        ctx.save();
        ctx.translate(x + w/2, y + h/2);
        ctx.rotate(rotation);
        ctx.translate(-w/2, -h/2);

        // ç•«å‘å³çš„è·³æ¿ (åº•éƒ¨åœ¨å·¦é‚Šï¼Œå½ˆåŠ›å‘å³)
        ctx.fillStyle = '#558b2f'; // æ·±ç¶ åº•åº§
        ctx.fillRect(0, 0, w/3, h);
        
        ctx.fillStyle = COLORS.spring; // æ·ºç¶ å½ˆæ€§éƒ¨
        ctx.fillRect(w/3, 5, w*0.6, h-10);
        
        ctx.strokeStyle = '#2e7d32';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w/3, 0);
        ctx.lineTo(w/3, h);
        ctx.stroke();
        
        ctx.restore();

    } else if (type === 'pushbox') {
        ctx.fillStyle = COLORS.pushbox;
        ctx.strokeStyle = '#ef6c00';
        ctx.lineWidth = 4;
        drawRoundedRect(ctx, x, y, w, h, 8);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#ffe0b2';
        ctx.beginPath();
        ctx.arc(x+w/2, y+h/2, 10, 0, Math.PI*2);
        ctx.fill();
    }
}

// =========================================
// é¡åˆ¥å®šç¾©
// =========================================

class Entity {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.w = TILE_SIZE;
        this.h = TILE_SIZE;
        this.vx = 0;
        this.vy = 0;
        this.type = type;
        this.isGrounded = false;
        this.toRemove = false;
        this.facingRight = true;
    }

    update() {
        this.vy += GRAVITY;
        if (this.vy > TERMINAL_VELOCITY) this.vy = TERMINAL_VELOCITY;
    }

    draw(ctx) {
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y, this.w, this.h);
    }

    getGridPos() {
        return {
            c: Math.floor((this.x + this.w/2) / TILE_SIZE),
            r: Math.floor((this.y + this.h/2) / TILE_SIZE)
        };
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 'player');
        this.w = TILE_SIZE * 0.7; 
        this.h = TILE_SIZE * 0.7;
        this.x += (TILE_SIZE - this.w) / 2;
        this.y += (TILE_SIZE - this.h);
        
        this.speed = 6;
        this.jumpForce = -14;
        this.canDoubleJump = false;
        this.jumpCount = 0;
    }

    update() {
        let moveLeft = keys.ArrowLeft || keys.KeyA || touchInputs.left;
        let moveRight = keys.ArrowRight || keys.KeyD || touchInputs.right;
        
        // è®“ç‰©ç†å¼•æ“è™•ç†æ°´å¹³é€Ÿåº¦ï¼Œé€™è£¡åªè¨­å®šæ„åœ–
        if (moveLeft) {
            this.vx = -this.speed;
            this.facingRight = false;
        } else if (moveRight) {
            this.vx = this.speed;
            this.facingRight = true;
        } else {
             this.vx = 0;
        }

        super.update();

        if (this.y > 2000) die();
    }

    jump() {
        if (this.isGrounded) {
            this.vy = this.jumpForce;
            this.isGrounded = false;
            this.jumpCount = 1;
            this.canDoubleJump = true;
            createParticles(this.x + this.w/2, this.y + this.h, COLORS.playerMain, 5);
        } else if (this.canDoubleJump && this.jumpCount < 2) {
            this.vy = this.jumpForce * 0.9;
            this.jumpCount = 2;
            this.canDoubleJump = false;
            createParticles(this.x + this.w/2, this.y + this.h, '#fff', 5);
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        
        // åªæœ‰åœ¨çœŸæ­£éŠç©ä¸”æœªè½åœ°æ™‚æ‰åšæ“ å£“å‹•ç•«
        if (!this.isGrounded && mode === 'play') {
            ctx.scale(0.9, 1.1);
        } else if (Math.abs(this.vx) > 0.1 && mode === 'play') {
            let bounce = Math.sin(Date.now() / 50) * 0.1;
            ctx.scale(1 + bounce, 1 - bounce);
        }

        ctx.fillStyle = COLORS.playerMain;
        ctx.beginPath();
        ctx.arc(0, 0, this.w/2, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = COLORS.playerStroke;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        let faceX = this.facingRight ? 4 : -4;

        ctx.fillStyle = '#3e2723';
        ctx.beginPath();
        ctx.arc(faceX - 6, -4, 5, 0, Math.PI*2); 
        ctx.arc(faceX + 6, -4, 5, 0, Math.PI*2); 
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(faceX - 4, -6, 2, 0, Math.PI*2);
        ctx.arc(faceX + 8, -6, 2, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = '#ffab91'; 
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(faceX - 10, 5, 4, 0, Math.PI*2);
        ctx.arc(faceX + 10, 5, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        ctx.strokeStyle = '#3e2723';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(faceX, 5, 3, 0, Math.PI); 
        ctx.stroke();

        ctx.restore();
    }
}

class Monster extends Entity {
    constructor(x, y, dir = -1) {
        super(x, y, 'monster');
        this.speed = 2;
        this.dir = (Math.abs(dir) !== 1) ? 1 : dir;
        this.detectRange = TILE_SIZE * 8;
        this.activateTime = 0; // å•Ÿå‹•æ™‚é–“æˆ³è¨˜
    }

    update() {
        super.update();
        
        // 0.5 ç§’å»¶é²åˆ¤æ–·
        if (mode === 'play' && (Date.now() - this.activateTime < 500)) {
            this.vx = 0;
            return;
        }
        
        const player = dynamicObjects.find(o => o.type === 'player');
        if (player) {
            let dx = player.x - this.x;
            let dist = Math.sqrt(dx*dx + (player.y - this.y)*(player.y - this.y));

            if (dist < this.detectRange) {
                this.vx = (dx > 0 ? 1 : -1) * this.speed;
            } else {
                this.vx *= 0.9;
            }
        }
        
        if (Math.abs(this.vx) > 0.1) {
            this.dir = this.vx > 0 ? 1 : -1;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        
        let wobble = 0;
        if (mode === 'play') wobble = Math.sin(Date.now() / 100) * 5;
        
        ctx.fillStyle = COLORS.monster;
        ctx.beginPath();
        ctx.moveTo(-this.w/2, this.h/2);
        ctx.quadraticCurveTo(-this.w/2 + wobble, -this.h/2, 0, -this.h/2);
        ctx.quadraticCurveTo(this.w/2 + wobble, -this.h/2, this.w/2, this.h/2);
        ctx.fill();

        ctx.fillStyle = COLORS.monsterEyes;
        let eyeX = this.dir * 6;
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(eyeX - 10, -5);
        ctx.lineTo(eyeX - 2, 0);
        ctx.moveTo(eyeX + 2, 0);
        ctx.lineTo(eyeX + 10, -5);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(eyeX - 6, 5, 3, 0, Math.PI*2);
        ctx.arc(eyeX + 6, 5, 3, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

class PushBlock extends Entity {
    constructor(x, y) {
        super(x, y, 'pushbox');
        this.friction = 0.8; 
    }

    update() {
        this.vy += GRAVITY;
        this.vx *= this.friction;
    }

    draw(ctx) {
        drawTileGraphic(ctx, 'pushbox', this.x, this.y, this.w, this.h);
    }
}

class Particle {
    constructor(x, y, color, size, speed = 1) {
        this.x = x;
        this.y = y;
        this.color = color;
        let angle = Math.random() * Math.PI * 2;
        let v = Math.random() * 5 * speed + 2;
        this.vx = Math.cos(angle) * v;
        this.vy = Math.sin(angle) * v;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.size = size || (Math.random() * 5 + 3);
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.size *= 0.95;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// =========================================
// éŠæˆ²é‚è¼¯
// =========================================

function createParticles(x, y, color, count, speed = 1) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, null, speed));
    }
}

function createExplosion(x, y, color) {
    particles.push({
        x: x, y: y, type: 'ring', size: 10, life: 1, color: color,
        update: function() { this.size += 5; this.life -= 0.05; },
        draw: function(ctx) {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
    });
    createParticles(x, y, color, 20, 1.5);
    createParticles(x, y, '#fff', 10, 1);
}

function getKey(c, r) {
    return `${c},${r}`;
}

function getGridFromKey(key) {
    const parts = key.split(',');
    return { c: parseInt(parts[0]), r: parseInt(parts[1]) };
}

// é€šç”¨çš„ AABB ç¢°æ’æª¢æ¸¬ï¼Œè¿”å›ç¢°æ’çš„ç‰©ä»¶æˆ–æ–¹å¡Šè³‡è¨Š
function checkCollision(entity, dx, dy) {
    let newX = entity.x + dx;
    let newY = entity.y + dy;

    // æ”¶ç¸®é‚Šç•Œé‚è¼¯ (Narrow Collision)
    // ç”¨æ–¼å‚ç›´æª¢æ¸¬æ™‚ï¼Œå¿½ç•¥æ¥µå°çš„å´é¢é‡ç–Šï¼Œé˜²æ­¢ã€Œç‰†å£é»æ»¯ã€æˆ–ã€Œæ–¹å¡Šå †ç–Šã€Bug
    let checkX = newX;
    let checkW = entity.w;
    if (dx === 0 && dy !== 0) {
        let margin = 4; // ç¸®å°åµæ¸¬ç¯„åœï¼Œé¿å…é‚Šç·£èª¤è§¸
        checkX += margin;
        checkW -= margin * 2;
    }

    let startCol = Math.floor(checkX / TILE_SIZE);
    let endCol = Math.floor((checkX + checkW - 0.1) / TILE_SIZE);
    let startRow = Math.floor(newY / TILE_SIZE);
    let endRow = Math.floor((newY + entity.h - 0.1) / TILE_SIZE);

    // 1. åœ°å½¢ç¢°æ’
    for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
            let tileData = tiles[getKey(c, r)];
            if (tileData) {
                let type = tileData.split('_')[0];
                
                if (['ground', 'conveyor', 'spring', 'pushbox'].includes(type)) {
                    return { solid: true, type: type, fullType: tileData, c, r };
                }
                if (type === 'spike' && mode === 'play') {
                    let spikeX = c * TILE_SIZE + 10;
                    let spikeY = r * TILE_SIZE + 20;
                    let spikeW = TILE_SIZE - 20;
                    let spikeH = TILE_SIZE - 20;
                    
                    if (newX < spikeX + spikeW && newX + entity.w > spikeX &&
                        newY < spikeY + spikeH && newY + entity.h > spikeY) {
                        if (entity.type === 'player') die();
                    }
                }
            }
        }
    }
    
    // 2. å¯¦é«”ç¢°æ’ (ç®±å­èˆ‡ç®±å­ï¼Œç©å®¶èˆ‡ç®±å­ï¼Œæ€ªç‰©èˆ‡ç®±å­)
    // åŠ å…¥ monster æª¢æŸ¥ï¼Œç¢ºä¿æ€ªç‰©ä¸æœƒç©¿éç®±å­
    if (entity.type === 'player' || entity.type === 'pushbox' || entity.type === 'monster') {
        for (let other of dynamicObjects) {
            if (other === entity) continue;
            if (other.toRemove) continue;
            
            // åªæœ‰ç¢°æ’ç®±å­æ‰æœ‰ç‰©ç†æ¨å‹• (æˆ–é˜»æ“‹)
            if (other.type !== 'pushbox') continue;

            // ä½¿ç”¨æ”¶ç¸®å¾Œçš„ X ç¯„åœé€²è¡Œå‚ç›´æª¢æ¸¬
            if (checkX < other.x + other.w && checkX + checkW > other.x &&
                newY < other.y + other.h && newY + entity.h > other.y) {
                return { solid: true, type: 'entity_box', entity: other };
            }
        }
    }
    return null;
}

function updatePhysics() {
    let player = dynamicObjects.find(o => o.type === 'player');

    // --- æˆ°é¬¥åˆ¤å®š (å„ªå…ˆè™•ç†) ---
    if (player) {
        dynamicObjects.forEach(monster => {
            if (monster.type === 'monster' && !monster.toRemove) {
                // ç°¡å–® AABB é åˆ¤
                if (player.x < monster.x + monster.w &&
                    player.x + player.w > monster.x &&
                    player.y < monster.y + monster.h &&
                    player.y + player.h > monster.y) {
                    
                    // è¸©è¸åˆ¤å®š
                    if (player.vy >= -1 && (player.y + player.h) < (monster.y + monster.h * 0.6)) {
                        monster.toRemove = true;
                        player.vy = -10; // å½ˆè·³
                        createExplosion(monster.x + monster.w/2, monster.y + monster.h/2, COLORS.monster);
                        return; // é¿å…åŒæ™‚è§¸ç™¼æ­»äº¡
                    } else {
                        die();
                    }
                }
            }
        });
    }
    
    dynamicObjects.forEach(obj => {
        if (obj.toRemove) return;

        // --- X è»¸ç§»å‹• (å«é€£é–æ¨ç®±å­) ---
        let colX = checkCollision(obj, obj.vx, 0);
        
        if (colX && colX.solid) {
            let pushed = false;

            // é€£é–æ¨ç®±å­é‚è¼¯ (åƒ…ç©å®¶)
            if (obj.type === 'player' && colX.type === 'entity_box') {
                // å°‹æ‰¾é€£é–çš„ç®±å­
                let stack = [];
                let currBox = colX.entity;
                let blocked = false;
                
                // é åˆ¤æ–¹å‘
                let pushDir = obj.vx > 0 ? 1 : -1;
                
                // æ”¶é›†æ‰€æœ‰é€£åœ¨ä¸€èµ·çš„ç®±å­
                for(let i=0; i<5; i++) {
                    if (!stack.includes(currBox)) {
                         stack.push(currBox);
                    }
                    
                    // æª¢æŸ¥é€™å€‹ç®±å­å‰æ–¹æ˜¯å¦æœ‰éšœç¤™ç‰©
                    let nextCol = checkCollision(currBox, pushDir * (TILE_SIZE/2), 0); 
                    
                    if (nextCol && nextCol.solid) {
                        if (nextCol.type === 'entity_box') {
                            currBox = nextCol.entity; // ç¹¼çºŒæª¢æŸ¥ä¸‹ä¸€å€‹ç®±å­
                        } else {
                            blocked = true; // æ’ç‰†ï¼Œæ•´æ’å¡ä½
                            break; 
                        }
                    } else {
                        break; // å‰æ–¹ç©ºæ°£ï¼Œå¯æ¨
                    }
                }

                if (!blocked && stack.length > 0) {
                    // è¨ˆç®—æ¨å‹•é€Ÿåº¦ (ç®±å­è¶Šå¤šè¶Šæ…¢)
                    let pushSpeed = obj.vx / (stack.length + 0.8); 
                    
                    // ç§»å‹•æ‰€æœ‰ç®±å­
                    stack.forEach(b => b.x += pushSpeed);
                    // ç©å®¶ä¹Ÿç¨å¾®ç§»å‹•
                    obj.x += pushSpeed;
                    pushed = true;
                }
            }

            // å‚ç›´è¼¸é€å¸¶ (ç‰†å£æ•ˆæœ)
            if (!pushed && colX.type === 'conveyor') {
                if (colX.fullType.includes('up')) {
                    obj.vy = -4; 
                } else if (colX.fullType.includes('down')) {
                    obj.vy = 4; 
                }
                obj.vx = 0; // æ’ç‰†åœæ­¢
            } else if (!pushed) {
                obj.vx = 0; // æ™®é€šæ’ç‰† (æ€ªç‰©ç¢°åˆ°ç®±å­ä¹Ÿæœƒåœåœ¨é€™)
            }
        } else {
            obj.x += obj.vx;
        }

        // --- Y è»¸ç§»å‹• ---
        obj.isGrounded = false;
        let colY = checkCollision(obj, 0, obj.vy);
        
        if (colY && (colY.solid || colY.type === 'entity_box')) {
            if (obj.vy > 0) { // è½åœ°
                obj.isGrounded = true;
                
                // ä½ç½®ä¿®æ­£
                if(colY.type !== 'entity_box') {
                     obj.y = colY.r * TILE_SIZE - obj.h;
                } else {
                     obj.y = colY.entity.y - obj.h;
                }
                
                if (obj.type === 'player') {
                    obj.jumpCount = 0;
                    obj.canDoubleJump = true;
                }

                // æ°´å¹³è¼¸é€å¸¶
                if (colY.type === 'conveyor') {
                    if (colY.fullType.includes('right')) obj.x += 3;
                    if (colY.fullType.includes('left')) obj.x -= 3;
                }

                // è·³æ¿é‚è¼¯ (æ”¯æ´æ–¹å‘)
                if (colY.type === 'spring') {
                    let sDir = 'up';
                    if (colY.fullType.includes('_')) sDir = colY.fullType.split('_')[1];
                    
                    obj.isGrounded = false;
                    
                    if (sDir === 'up') { obj.vy = -22; }
                    else if (sDir === 'down') { obj.vy = 22; } // å¾€ä¸‹å½ˆ
                    else if (sDir === 'left') { obj.vx = -20; obj.vy = -10; } // å‘å·¦å½ˆå°„
                    else if (sDir === 'right') { obj.vx = 20; obj.vy = -10; } // å‘å³å½ˆå°„
                    
                    createParticles(obj.x + obj.w/2, obj.y + obj.h, COLORS.spring, 8);
                } else {
                    obj.vy = 0;
                }
            } else if (obj.vy < 0) { // é ‚é ­
                obj.vy = 0;
                if(colY.type !== 'entity_box') {
                    obj.y = (colY.r + 1) * TILE_SIZE;
                } else {
                    obj.y = colY.entity.y + colY.entity.h;
                }
            }
        } else {
            obj.y += obj.vy;
        }
    });
}

function die() {
    const player = dynamicObjects.find(o => o.type === 'player');
    let x = camera.x + canvas.width/2;
    let y = camera.y + canvas.height/2;
    if(player) {
        x = player.x + player.w/2;
        y = player.y + player.h/2;
    }

    createExplosion(x, y, COLORS.playerMain);
    showMessage("ä½ æ­»æ‰äº†ï¼");
    setTimeout(() => {
        resetLevel();
    }, 800);
}

function resetLevel() {
    if (!savedMapData) return;
    tiles = {};
    dynamicObjects = [];
    particles = [];
    Object.assign(tiles, savedMapData.tiles);
    savedMapData.entities.forEach(eData => {
        if (eData.type === 'player') {
            let p = new Player(eData.x, eData.y);
            dynamicObjects.push(p);
            camera.x = p.x - canvas.width/2;
            camera.y = p.y - canvas.height/2;
        } else if (eData.type === 'monster') {
            let m = new Monster(eData.x, eData.y, eData.dir);
            m.activateTime = Date.now(); // é‡ç½®æ™‚ï¼Œå»¶é²è¨ˆæ™‚å™¨æ›´æ–°
            dynamicObjects.push(m);
        } else if (eData.type === 'pushbox') {
            dynamicObjects.push(new PushBlock(eData.x, eData.y));
        }
    });
}

// =========================================
// æ¸²æŸ“å¾ªç’°
// =========================================

function drawGrid() {
    let startCol = Math.floor(camera.x / TILE_SIZE);
    let endCol = startCol + (canvas.width / TILE_SIZE) + 1;
    let startRow = Math.floor(camera.y / TILE_SIZE);
    let endRow = startRow + (canvas.height / TILE_SIZE) + 1;

    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';

    if (mode === 'build') {
        for (let c = startCol; c <= endCol; c++) {
            ctx.beginPath();
            ctx.moveTo(c * TILE_SIZE - camera.x, 0);
            ctx.lineTo(c * TILE_SIZE - camera.x, canvas.height);
            ctx.stroke();
        }
        for (let r = startRow; r <= endRow; r++) {
            ctx.beginPath();
            ctx.moveTo(0, r * TILE_SIZE - camera.y);
            ctx.lineTo(canvas.width, r * TILE_SIZE - camera.y);
            ctx.stroke();
        }
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillText("(0,0) èµ·é»", -camera.x + 5, -camera.y + 15);
    }

    for (let key in tiles) {
        let type = tiles[key];
        let pos = getGridFromKey(key);
        let screenX = pos.c * TILE_SIZE - camera.x;
        let screenY = pos.r * TILE_SIZE - camera.y;

        if (screenX < -TILE_SIZE || screenX > canvas.width || screenY < -TILE_SIZE || screenY > canvas.height) continue;
        
        // æª¢æŸ¥ä¸Šæ–¹æ˜¯å¦æœ‰æ–¹å¡Š
        let aboveKey = getKey(pos.c, pos.r - 1);
        let isGrassBlocked = tiles.hasOwnProperty(aboveKey);

        drawTileGraphic(ctx, type, screenX, screenY, TILE_SIZE, TILE_SIZE, isGrassBlocked);
    }
}

function drawPreview() {
    if (mode !== 'build' || currentTool === 'eraser') return;

    let mx = lastMousePos.x + camera.x;
    let my = lastMousePos.y + camera.y;
    let c = Math.floor(mx / TILE_SIZE);
    let r = Math.floor(my / TILE_SIZE);
    
    let x = c * TILE_SIZE;
    let y = r * TILE_SIZE;

    // æª¢æŸ¥é è¦½æ–¹å¡Šçš„ä¸Šæ–¹æ˜¯å¦æœ‰æ–¹å¡Š
    let aboveKey = getKey(c, r - 1);
    let isGrassBlocked = tiles.hasOwnProperty(aboveKey);

    ctx.save();
    ctx.globalAlpha = 0.6;
    
    if (['player', 'monster'].includes(currentTool)) {
        if (currentTool === 'player') {
            let tempPlayer = new Player(x, y);
            tempPlayer.isGrounded = true; 
            tempPlayer.x = x - camera.x;
            tempPlayer.y = y - camera.y;
            tempPlayer.draw(ctx);
        } else if (currentTool === 'monster') {
            ctx.fillStyle = COLORS.monster;
            ctx.translate(x - camera.x, y - camera.y);
            ctx.beginPath();
            ctx.moveTo(0, TILE_SIZE);
            ctx.quadraticCurveTo(TILE_SIZE/2, 0, TILE_SIZE, TILE_SIZE);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            const ARROWS = ['â†’', 'â†“', 'â†', 'â†‘'];
            ctx.fillText(ARROWS[buildDir], 20, 30);
        }
    } else {
        let previewType = currentTool;
        if (currentTool === 'conveyor' || currentTool === 'spring') {
            previewType = currentTool + '_' + DIR_NAMES[buildDir];
        }
        drawTileGraphic(ctx, previewType, x - camera.x, y - camera.y, TILE_SIZE, TILE_SIZE, isGrassBlocked);
    }
    
    ctx.restore();
    
    ctx.strokeStyle = '#4caf50';
    ctx.lineWidth = 2;
    ctx.strokeRect(x - camera.x, y - camera.y, TILE_SIZE, TILE_SIZE);
}

function updateCamera() {
    if (mode === 'build') {
        const CAM_SPEED = 15;
        if (keys.ArrowLeft || keys.KeyA) camera.x -= CAM_SPEED;
        if (keys.ArrowRight || keys.KeyD) camera.x += CAM_SPEED;
        if (keys.ArrowUp || keys.KeyW) camera.y -= CAM_SPEED;
        if (keys.ArrowDown || keys.KeyS) camera.y += CAM_SPEED;
    }
}

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (mode === 'play') {
        dynamicObjects = dynamicObjects.filter(o => !o.toRemove);
        dynamicObjects.forEach(o => o.update());

        updatePhysics();

        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => p.update());

        const player = dynamicObjects.find(o => o.type === 'player');
        if (player) {
            let targetX = player.x + player.w/2 - canvas.width/2;
            let targetY = player.y + player.h/2 - canvas.height/2;
            camera.x += (targetX - camera.x) * 0.1;
            camera.y += (targetY - camera.y) * 0.1;
        }
    } else {
        // å»ºé€ æ¨¡å¼ä¸‹çš„é¡é ­æ›´æ–°
        updateCamera();
    }

    drawGrid();

    if (mode === 'build') {
        drawPreview();
    }

    ctx.save();
    ctx.translate(-camera.x, -camera.y);
    
    dynamicObjects.forEach(obj => obj.draw(ctx));
    particles.forEach(p => p.draw(ctx));
    ctx.restore();

    requestAnimationFrame(gameLoop);
}

// =========================================
// äº¤äº’èˆ‡æ§åˆ¶
// =========================================

function toggleMode() {
    const btn = document.getElementById('mode-switch');
    const toolbar = document.getElementById('toolbar');
    const mobileControls = document.getElementById('mobile-controls');

    if (mode === 'build') {
        let hasPlayer = dynamicObjects.some(e => e.type === 'player');

        if (!hasPlayer) {
            showMessage("å¿…é ˆæ”¾ç½®ä¸€å€‹ä¸»è§’æ‰èƒ½é–‹å§‹ï¼");
            return;
        }

        savedMapData = {
            tiles: {...tiles},
            entities: dynamicObjects.map(o => ({type: o.type, x: o.x, y: o.y, dir: o.dir}))
        };

        mode = 'play';
        
        // åˆ‡æ›åˆ° Play æ™‚ï¼Œé‡ç½®æ€ªç‰©çš„å•Ÿå‹•æ™‚é–“
        dynamicObjects.forEach(o => {
            if(o.type === 'monster') o.activateTime = Date.now();
        });

        btn.innerHTML = 'ğŸ”¨';
        btn.classList.add('playing');
        toolbar.classList.add('hidden'); 
        mobileControls.classList.add('active');
        showMessage("éŠç©æ¨¡å¼é–‹å§‹ï¼");

    } else {
        mode = 'build';
        btn.innerHTML = 'â–¶ï¸';
        btn.classList.remove('playing');
        toolbar.classList.remove('hidden'); 
        mobileControls.classList.remove('active');
        
        resetLevel();
        
        dynamicObjects.forEach(o => { o.vx = 0; o.vy = 0; });
        const p = dynamicObjects.find(o => o.type === 'player');
        if(p) {
            camera.x = p.x - canvas.width/2;
            camera.y = p.y - canvas.height/2;
        }
    }
}

function selectTool(tool) {
    currentTool = tool;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    const buttons = document.querySelectorAll('.tool-btn');
    buttons.forEach(btn => {
        if(btn.title.includes(toolToName(tool))) btn.classList.add('active');
    });
    if(event && event.currentTarget) {
        buttons.forEach(b => b.classList.remove('active'));
        event.currentTarget.classList.add('active');
    }
}

function toolToName(tool) {
    const map = {
        'ground': 'æ–¹å¡Š', 'player': 'ä¸»è§’', 'spike': 'å°–åˆº',
        'conveyor': 'è¼¸é€å¸¶', 'spring': 'è·³æ¿', 'pushbox': 'æ¨å‹•',
        'monster': 'æ€ªç‰©', 'eraser': 'æ©¡çš®æ“¦'
    };
    return map[tool] || tool;
}

function toggleBuildDir() {
    buildDir = (buildDir + 1) % 4; // 0->1->2->3->0
    
    const btn = document.getElementById('rotate-btn');
    const ARROWS = ['â¡ï¸', 'â¬‡ï¸', 'â¬…ï¸', 'â¬†ï¸'];
    btn.innerHTML = ARROWS[buildDir];
    
    btn.style.transform = 'scale(1.2)';
    setTimeout(() => btn.style.transform = 'scale(1)', 100);
    
    const NAMES = ['å³', 'ä¸‹', 'å·¦', 'ä¸Š'];
    showMessage(`æ–¹å‘: ${NAMES[buildDir]}`);
}

function showMessage(msg) {
    const el = document.getElementById('message');
    el.innerText = msg;
    el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 2000);
}

let isMouseDown = false;

canvas.addEventListener('mousedown', e => {
    isMouseDown = true;
    lastMousePos = { x: e.clientX, y: e.clientY };
    if (mode === 'build') handleBuildClick(e.clientX, e.clientY, false);
});

canvas.addEventListener('mousemove', e => {
    lastMousePos = { x: e.clientX, y: e.clientY }; 
    if (isMouseDown && mode === 'build') {
        handleBuildClick(e.clientX, e.clientY, true);
    }
});

canvas.addEventListener('mouseup', () => isMouseDown = false);

function handleBuildClick(screenX, screenY, isDragging) {
    let worldX = screenX + camera.x;
    let worldY = screenY + camera.y;
    
    let c = Math.floor(worldX / TILE_SIZE);
    let r = Math.floor(worldY / TILE_SIZE);
    let key = getKey(c, r);

    // Check if trying to place tile or entity
    let isEntityTool = ['player', 'monster', 'pushbox'].includes(currentTool);

    if (currentTool === 'eraser') {
        delete tiles[key];
        dynamicObjects = dynamicObjects.filter(o => {
            let grid = o.getGridPos();
            return !(grid.c === c && grid.r === r);
        });
    } 
    else if (isEntityTool) {
        // æ”¾ç½®å¯¦é«”é‚è¼¯ (ä¸æ”¯æ´æ‹–æ›³ï¼Œæˆ–å¯è€ƒæ…®æ”¯æ´)
        if (!isDragging || currentTool === 'eraser') { // å¯¦é«”ä¸å»ºè­°æ‹–æ›³æ”¾ç½®ï¼Œå®¹æ˜“é‡ç–Š
            if (isDragging) return;

            // 1. æ¸…é™¤è©²æ ¼å­çš„æ‰€æœ‰å¯¦é«” (é¿å…é‡ç–Š)
            dynamicObjects = dynamicObjects.filter(o => {
                let grid = o.getGridPos();
                return !(grid.c === c && grid.r === r);
            });

            // 2. æ¸…é™¤è©²æ ¼å­çš„æ–¹å¡Š (äº’æ–¥é‚è¼¯ï¼šæœ‰äº†å¯¦é«”å°±ä¸èƒ½æœ‰æ–¹å¡Š)
            if (tiles[key]) {
                delete tiles[key];
            }

            // 3. æ”¾ç½®æ–°å¯¦é«”
            if (currentTool === 'player') {
                // ç§»é™¤å ´ä¸Šå…¶ä»–ä¸»è§’ (å”¯ä¸€æ€§)
                dynamicObjects = dynamicObjects.filter(o => o.type !== 'player');
                let p = new Player(c * TILE_SIZE, r * TILE_SIZE);
                dynamicObjects.push(p);
            }
            else if (currentTool === 'monster') {
                let mDir = (buildDir === 2) ? -1 : 1; 
                let m = new Monster(c * TILE_SIZE, r * TILE_SIZE, mDir);
                dynamicObjects.push(m);
            }
            else if (currentTool === 'pushbox') {
                dynamicObjects.push(new PushBlock(c * TILE_SIZE, r * TILE_SIZE));
            }
        }
    } 
    else {
        // æ”¾ç½®æ–¹å¡Šé‚è¼¯
        
        // 1. æ¸…é™¤è©²æ ¼å­çš„å¯¦é«” (äº’æ–¥é‚è¼¯ï¼šæœ‰äº†æ–¹å¡Šå°±ä¸èƒ½æœ‰å¯¦é«”)
        dynamicObjects = dynamicObjects.filter(o => {
            let grid = o.getGridPos();
            return !(grid.c === c && grid.r === r);
        });

        // 2. æ”¾ç½®/æ—‹è½‰æ–¹å¡Š
        if (!isDragging && (currentTool === 'conveyor' || currentTool === 'spring') && tiles[key] && tiles[key].startsWith(currentTool)) {
             let currentDirStr = tiles[key].split('_')[1] || 'right';
             let currentIdx = DIR_NAMES.indexOf(currentDirStr);
             let nextIdx = (currentIdx + 1) % 4;
             tiles[key] = currentTool + '_' + DIR_NAMES[nextIdx];
        } else {
             let type = currentTool;
             if (currentTool === 'conveyor' || currentTool === 'spring') {
                 type = currentTool + '_' + DIR_NAMES[buildDir];
             }
             tiles[key] = type;
        }
    }
}

window.addEventListener('keydown', e => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
    
    if (mode === 'play') {
        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
            const p = dynamicObjects.find(o => o.type === 'player');
            if (p) p.jump();
        }
    } else {
        if (e.code === 'KeyR') {
            toggleBuildDir();
        }
    }
});

window.addEventListener('keyup', e => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
});

const btnLeft = document.getElementById('btn-left');
const btnRight = document.getElementById('btn-right');
const btnJump = document.getElementById('btn-jump');

btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); touchInputs.left = true; });
btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); touchInputs.left = false; });

btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); touchInputs.right = true; });
btnRight.addEventListener('touchend', (e) => { e.preventDefault(); touchInputs.right = false; });

btnJump.addEventListener('touchstart', (e) => { 
    e.preventDefault(); 
    touchInputs.jump = true;
    const p = dynamicObjects.find(o => o.type === 'player');
    if (p) p.jump();
});
btnJump.addEventListener('touchend', (e) => { e.preventDefault(); touchInputs.jump = false; });


function initWorld() {
    tiles = {};
    dynamicObjects = [];
    camera.x = -canvas.width / 2 + 300;
    camera.y = -canvas.height / 2 + 300;
    currentTool = 'ground';
    showMessage("è«‹æ”¾ç½®ä¸»è§’å’Œæ–¹å¡Šä¾†é–‹å§‹ï¼(æŒ‰ R æ—‹è½‰)");
}

initWorld();
gameLoop();

</script>
</body>
</html>
